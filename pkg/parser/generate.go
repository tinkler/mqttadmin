package parser

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/tinkler/mqttadmin/pkg/jsonz/cjson"
	"github.com/tinkler/mqttadmin/pkg/jsonz/sjson"
)

// GenerateRoutes generate routes for package using template.
func GenerateChiRoutes(path string, pkg *Package, dep map[string]*Package) error {
	f, err := os.Create(filepath.Join(path, fmt.Sprintf("%s.go", pkg.Name)))
	if err != nil {
		return err
	}
	defer f.Close()

	debugPathFile, err := os.Create(filepath.Join(path, fmt.Sprintf("%s_path.go", pkg.Name)))
	if err != nil {
		return err
	}
	defer debugPathFile.Close()

	{
		f.WriteString(fmt.Sprintln("// Code generated by github.com/tinkler/mqttadmin; DO NOT EDIT."))
		f.WriteString(fmt.Sprintln("package route"))

		debugPathFile.WriteString(fmt.Sprintln("// Code generated by github.com/tinkler/mqttadmin; DO NOT EDIT."))
		debugPathFile.WriteString(fmt.Sprintln("package route"))
	}

	var (
		usedDepStruct = make(map[string]map[string]bool)
		hasMethods    bool
	)
	for _, s := range pkg.Structs {
		fields := make([]Field, 0)
		for _, m := range s.Methods {
			fields = append(fields, m.Args...)
			fields = append(fields, m.Rets...)
			hasMethods = true
		}
		for _, f := range fields {
			typ := f.Type
		FIND:
			typ = strings.TrimPrefix(typ, "*")
			if _, isBt := tsTypeMap[typ]; !isBt {
				if FindStruct(pkg, typ) == nil {
					if dep != nil {
						if nameSlice := strings.Split(typ, "."); len(nameSlice) > 1 {
							if _, isDep := dep[nameSlice[0]]; isDep {
								if FindStruct(dep[nameSlice[0]], nameSlice[1]) == nil {
									return fmt.Errorf("type %s not found", typ)
								} else {
									if usedDepStruct[nameSlice[0]] == nil {
										usedDepStruct[nameSlice[0]] = make(map[string]bool)
									}
									usedDepStruct[nameSlice[0]][nameSlice[1]] = true
								}
							} else {
								if strings.HasPrefix(typ, "[]") {
									typ = strings.TrimPrefix(typ, "[]")
									goto FIND
								} else {
									return fmt.Errorf("package %s not found", nameSlice[0])
								}
							}
						}

					}
				}
			}
		}
	}

	{
		f.WriteString(fmt.Sprintln("import ("))
		if hasMethods {
			f.WriteString(fmt.Sprintln("\t\"net/http\""))
			f.WriteString(fmt.Sprintln())
		}

		f.WriteString(fmt.Sprintln("\t\"github.com/go-chi/chi/v5\""))
		if hasMethods {
			f.WriteString(fmt.Sprintln("\t\"github.com/tinkler/mqttadmin/pkg/jsonz/sjson\""))
			f.WriteString(fmt.Sprintf("\t\"%s\"\n", pkg.ImportsMap[pkg.Name]))
			f.WriteString(fmt.Sprintln("\t\"github.com/tinkler/mqttadmin/pkg/status\""))
		}
		for _, importName := range pkg.Imports {
			if _, used := usedDepStruct[importName]; used {
				f.WriteString(fmt.Sprintf("\t\"%s\"\n", pkg.ImportsMap[importName]))
			}
		}

		f.WriteString(fmt.Sprintln(")"))
	}

	{
		t := template.Must(template.New("model").Funcs(template.FuncMap{
			"toType": func(typ string) string {
				if _, isBt := tsTypeMap[typ]; isBt {
					return typ
				}
				if sli := strings.Split(typ, "."); len(sli) > 1 {
					return typ
				}
				if strings.HasPrefix(typ, "*") {
					typ = strings.TrimPrefix(typ, "*")
					return fmt.Sprintf("*%s.%s", pkg.Name, typ)
				}
				if strings.HasPrefix(typ, "[]") {
					typ = strings.TrimPrefix(typ, "[]")
					if strings.HasPrefix(typ, "*") {
						typ = strings.TrimPrefix(typ, "*")
						return fmt.Sprintf("[]*%s.%s", pkg.Name, typ)
					}
					return fmt.Sprintf("[]%s.%s", pkg.Name, typ)
				}
				return fmt.Sprintf("%s.%s", pkg.Name, typ)
			},
			"toSnack": func(s string) string {
				return sjson.ToSnackedName(s)
			},
			"toFulle": func(s string) string {
				return cjson.SnakeCaseToFullCamelCase(s)
			},
			"toMinus": func(s string) string {
				return strings.ReplaceAll(sjson.ToSnackedName(s), "_", "-")
			},
		}).Parse(goChiRouteTemplate))
		if err := t.Execute(f, pkg); err != nil {
			return err
		}

		if hasMethods {
			t := template.Must(template.New("model").Funcs(template.FuncMap{
				"toType": func(typ string) string {
					if _, isBt := tsTypeMap[typ]; isBt {
						return typ
					}
					if sli := strings.Split(typ, "."); len(sli) > 1 {
						return typ
					}
					if strings.HasPrefix(typ, "*") {
						typ = strings.TrimPrefix(typ, "*")
						return fmt.Sprintf("*%s.%s", pkg.Name, typ)
					}
					if strings.HasPrefix(typ, "[]") {
						typ = strings.TrimPrefix(typ, "[]")
						if strings.HasPrefix(typ, "*") {
							typ = strings.TrimPrefix(typ, "*")
							return fmt.Sprintf("[]*%s.%s", pkg.Name, typ)
						}
						return fmt.Sprintf("[]%s.%s", pkg.Name, typ)
					}
					return fmt.Sprintf("%s.%s", pkg.Name, typ)
				},
				"toSnack": func(s string) string {
					return sjson.ToSnackedName(s)
				},
				"toFulle": func(s string) string {
					return cjson.SnakeCaseToFullCamelCase(s)
				},
				"toMinus": func(s string) string {
					return strings.ReplaceAll(sjson.ToSnackedName(s), "_", "-")
				},
			}).Parse(goChiRouteDebugPathTemplate))
			if err := t.Execute(debugPathFile, pkg); err != nil {
				return err
			}
		}
	}

	return nil
}

// go route template
const goChiRouteTemplate = `
func Routes{{.Name | toFulle}}(m chi.Router) {
	m.Route("/{{.Name}}", func(r chi.Router) {
		{{range .Structs}}{{$struct := .}}{{range .Methods}}{{if eq .Type 0}}
		r.Post("/{{$struct.Name | toSnack}}/{{.Name | toMinus}}", func(w http.ResponseWriter, r *http.Request) {
			m := Model[*{{$struct.Name | toType}}, {{if .Args}}struct{
				{{range .Args}}{{.Name | toFulle}} {{.Type | toType}} 
				{{end}} } {{else}}any{{end}}]{}
			err := sjson.Bind(r, &m)
			if err != nil {
				http.Error(w, err.Error(), http.StatusBadRequest)
				return
			}
			res := Res[*{{$struct.Name | toType}},{{if ge (len .Rets) 1}}{{(index .Rets 0).Type | toType}}{{else}}any{{end}}]{Data:m.Data}
			{{if .Args}}{{if ge (len .Rets) 1}}res.Resp, err = m.Data.{{.Name}}(r.Context(){{if .Args}}, {{$rl := (len .Args)}}{{range $index,$arg := .Args}}m.Args.{{$arg.Name | toFulle}}{{if lt $index $rl}}, {{end}}{{end}}{{end}})
			{{else}}err = m.Data.{{.Name}}(r.Context(){{if .Args}}, {{$rl := (len .Args)}}{{range $index,$arg := .Args}}m.Args.{{$arg.Name | toFulle}}{{if lt $index $rl}}, {{end}}{{end}}{{end}})
			{{end}}{{else}}{{if ge (len .Rets) 1}}res.Resp, err = m.Data.{{.Name}}(r.Context())
			{{else}}err = m.Data.{{.Name}}(r.Context())
			{{end}}{{end}}
			if status.HttpError(w, err) {
				return
			}
			if sjson.HttpWrite(w, res) {
				return
			}

		}){{end}}{{end}}{{end}}
	})
}
`

// go route debug path template
const goChiRouteDebugPathTemplate = `{{$pkgName := .Name}}
func init() {
	{{range .Structs}}{{$struct := .}}{{range .Methods}}
	routePathMap["/{{$pkgName}}/{{$struct.Name | toSnack}}/{{.Name | toMinus}}"] = "{{.Filename}}:{{.StartLine}}"{{end}}{{end}}
}

`

func GenerateProtoFile(path string, moduleBasePath string, pkg *Package, dep map[string]*Package) error {

	protoPath := filepath.Join(path, fmt.Sprintf("%s/v1/%s.proto", pkg.Name, pkg.Name))
	pp, err := ParseProtoFile(protoPath)
	if err != nil {
		return err
	}

	var (
		usedDepStruct = make(map[string]map[string]bool)
		hasMethods    bool
		hasInterface  bool
	)
	for _, s := range pkg.Structs {
		fields := s.Fields
		for _, m := range s.Methods {
			hasMethods = true
			fields = append(fields, m.Args...)
			fields = append(fields, m.Rets...)
		}
		for _, f := range fields {
			typ := f.Type
			if strings.Contains(typ, "interface") {
				hasInterface = true
			}
		FIND:
			typ = strings.TrimPrefix(typ, "*")
			if _, isBt := tsTypeMap[typ]; !isBt {
				if FindStruct(pkg, typ) == nil {
					if dep != nil {
						if nameSlice := strings.Split(typ, "."); len(nameSlice) > 1 {
							if _, isDep := dep[nameSlice[0]]; isDep {
								if FindStruct(dep[nameSlice[0]], nameSlice[1]) == nil {
									return fmt.Errorf("type %s not found", typ)
								} else {
									if usedDepStruct[nameSlice[0]] == nil {
										usedDepStruct[nameSlice[0]] = make(map[string]bool)
									}
									usedDepStruct[nameSlice[0]][nameSlice[1]] = true
								}
							} else {
								if strings.HasPrefix(typ, "[]") {
									typ = strings.TrimPrefix(typ, "[]")
									goto FIND
								} else {
									return fmt.Errorf("package %s not found", nameSlice[0])
								}
							}
						}

					}
				}
			}
		}
	}

	protoFile, err := os.Create(protoPath)
	if err != nil {
		if os.IsNotExist(err) {
			os.MkdirAll(filepath.Dir(protoPath), os.ModePerm)
			protoFile, err = os.Create(protoPath)
			if err != nil {
				return err
			}
		} else {
			return err
		}

	}
	defer protoFile.Close()

	protoFile.WriteString(fmt.Sprintln("// Code generated by github.com/tinkler/mqttadmin; DO NOT EDIT."))
	protoFile.WriteString(fmt.Sprintln("syntax = \"proto3\";"))
	protoFile.WriteString(fmt.Sprintf("option go_package = \"%s/%s/v1;%s_v1\";\n", moduleBasePath, pkg.Name, pkg.Name))
	protoFile.WriteString(fmt.Sprintln("option java_multiple_files = true;"))
	protoFile.WriteString(fmt.Sprintf("option java_package = \"ink.sfs.tinkler.mqttadmin.%s.v1\";\n", pkg.Name))
	protoFile.WriteString(fmt.Sprintf("option java_outer_classname = \"%sProto\";\n", pkg.Name))
	protoFile.WriteString(fmt.Sprintf("package %s.v1;\n", pkg.Name))

	if hasMethods {
		protoFile.WriteString(fmt.Sprintln("import \"google/protobuf/any.proto\";"))
	}
	if hasInterface {
		protoFile.WriteString(fmt.Sprintln("import \"google/protobuf/struct.proto\";"))
	}

	if len(usedDepStruct) > 0 {
		for _, importName := range pkg.Imports {
			if _, ok := usedDepStruct[importName]; ok {
				protoFile.WriteString(fmt.Sprintf("import \"%s/v1/%s.proto\";\n", importName, importName))
			}
		}
	}

	protoFile.WriteString(fmt.Sprintln())

	for _, s := range pkg.Structs {
		protoFile.WriteString(fmt.Sprintf("message %s {\n", s.Name))
		for _, f := range s.Fields {
			goType := strings.ReplaceAll(f.Type, "*", "")
			isSlice := strings.HasPrefix(goType, "[]")
			var (
				isMap  = strings.HasPrefix(goType, "map")
				mapKey string
			)

			if isSlice {
				goType = strings.TrimPrefix(goType, "[]")
			}
			if isMap {
				match := mapTypeRe.FindStringSubmatch(goType)
				mapKey, goType = protoTypeMap[match[1]], match[2]
			}
			if buildinType, isBt := protoTypeMap[goType]; !isBt {
				if s := FindStruct(pkg, goType); s != nil {
					goType = s.Name
				}
				if dep != nil {
					if nameSlice := strings.Split(goType, "."); len(nameSlice) > 1 {
						if pkg, isDep := dep[nameSlice[0]]; isDep {
							if s := FindStruct(pkg, nameSlice[1]); s != nil {
								goType = pkg.Name + ".v1." + s.Name
							}
						}
					}
				}
			} else {
				goType = buildinType
			}
			if isSlice {
				goType = "repeated " + goType
			}
			if isMap {
				if goType == "interface" {
					goType = "google.protobuf.Value"
				}
				goType = "map<" + mapKey + "," + goType + ">"
			}
			protoFile.WriteString(fmt.Sprintf("\t%s %s = %d;\n", goType, sjson.ToSnackedName(f.Name), pp.GetSequence(sjson.ToSnackedName(s.Name), sjson.ToSnackedName(f.Name))))
		}
		protoFile.WriteString(fmt.Sprintln("}"))
		protoFile.WriteString(fmt.Sprintln())
	}

	protoFile.WriteString(fmt.Sprintln("service " + cjson.SnakeCaseToFullCamelCase(pkg.Name) + "Gsrv {"))
	for _, s := range pkg.Structs {
		for _, m := range s.Methods {
			switch m.Type {
			case MT_NORMAL:
				protoFile.WriteString(fmt.Sprintf("\trpc %s%s (google.protobuf.Any) returns (google.protobuf.Any);\n", s.Name, m.Name))
			case MT_BIDI:
				protoFile.WriteString(fmt.Sprintf("\trpc %s%s (stream google.protobuf.Any) returns (stream google.protobuf.Any);\n", s.Name, m.Name))
			}
		}
	}
	protoFile.WriteString(fmt.Sprintln("}"))

	// generate proto file by proto tool
	cmd := exec.Command("protoc", "-I", path, "--go_out=.", "--go_opt=paths=source_relative", "--go-grpc_out=.", "--go-grpc_opt=paths=source_relative", "--proto_path=.", protoPath)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	err = cmd.Run()
	if err != nil {
		return err
	}

	return nil
}

// GenerateGsrv generate grpc server
func GenerateGsrv(path string, modulePath string, pkg *Package, dep map[string]*Package) error {

	f, err := os.Create(filepath.Join(path, fmt.Sprintf("%s.go", pkg.Name)))
	if err != nil {
		return err
	}
	defer f.Close()

	var (
		usedDepStruct        = make(map[string]map[string]bool)
		hasMethods           bool
		hasStreamMethods     bool
		hasNullStreamMethods bool
		streamModels         = make(map[string]bool)
	)
	for _, s := range pkg.Structs {
		var fields []Field
		for _, m := range s.Methods {
			hasMethods = true
			if m.Type == MT_C2S ||
				m.Type == MT_S2C ||
				m.Type == MT_BIDI {
				hasStreamMethods = true
				if len(m.Args) > 0 {
					streamModels[strings.Split(strings.TrimPrefix(m.Args[0].Type, "*"), ".")[0]] = true
				} else {
					hasNullStreamMethods = true
				}
			}
			fields = append(fields, m.Args...)
			fields = append(fields, m.Rets...)
		}
		for _, f := range fields {
			typ := f.Type
		FIND:
			typ = strings.TrimPrefix(typ, "*")
			if _, isBt := tsTypeMap[typ]; !isBt {
				if FindStruct(pkg, typ) == nil {
					if dep != nil {
						if nameSlice := strings.Split(typ, "."); len(nameSlice) > 1 {
							if _, isDep := dep[nameSlice[0]]; isDep {
								if FindStruct(dep[nameSlice[0]], nameSlice[1]) == nil {
									return fmt.Errorf("type %s not found", typ)
								} else {
									if usedDepStruct[nameSlice[0]] == nil {
										usedDepStruct[nameSlice[0]] = make(map[string]bool)
									}
									usedDepStruct[nameSlice[0]][nameSlice[1]] = true
								}
							} else {
								if strings.HasPrefix(typ, "[]") {
									typ = strings.TrimPrefix(typ, "[]")
									goto FIND
								} else {
									return fmt.Errorf("package %s not found", nameSlice[0])
								}
							}
						}

					}
				}
			}
		}
	}

	f.WriteString(fmt.Sprintln("// Code generated by github.com/tinkler/mqttadmin; DO NOT EDIT."))
	f.WriteString(fmt.Sprintln("package gsrv"))

	f.WriteString(fmt.Sprintln("import ("))
	f.WriteString(fmt.Sprintln("\t\"context\""))

	if hasMethods {
		f.WriteString(fmt.Sprintln("\tmrz \"github.com/tinkler/mqttadmin/mrz/v1\""))
	}
	f.WriteString(fmt.Sprintf("\t\"%s\"\n", pkg.ImportsMap[pkg.Name]))
	f.WriteString(fmt.Sprintf("\tpb_%s_v1 \"%s/%s/v1\"\n", pkg.Name, modulePath, pkg.Name))
	if hasMethods && hasNullStreamMethods {
		f.WriteString(fmt.Sprintln("\tstructpb \"google.golang.org/protobuf/types/known/structpb\""))
	}
	if hasNullStreamMethods {
		f.WriteString(fmt.Sprintln("\tanypb \"google.golang.org/protobuf/types/known/anypb\""))
		f.WriteString(fmt.Sprintln("\t\"github.com/tinkler/mqttadmin/pkg/gs\""))
	}
	if hasStreamMethods {
		f.WriteString(fmt.Sprintln("\t\"github.com/tinkler/mqttadmin/pkg/jsonz/sjson\""))
	}

	for _, importName := range pkg.Imports {
		if _, used := usedDepStruct[importName]; used {
			f.WriteString(fmt.Sprintf("\t\"%s\"\n", pkg.ImportsMap[importName]))
			if streamModels[importName] {
				f.WriteString(fmt.Sprintf("\tpb_%s_v1 \"%s/%s/v1\"\n", importName, modulePath, importName))
			}
		}
	}

	f.WriteString(fmt.Sprintln(")"))

	t := template.New("gsrc").Funcs(template.FuncMap{
		"toFulle": func(s string) string {
			return cjson.SnakeCaseToFullCamelCase(s)
		},
		"toCamel": func(s string) string {
			return cjson.ToCamel(s)
		},
		"toType": func(goType string) string {
			prefix := ""
			if strings.HasPrefix(goType, "[]") {
				prefix = "[]"
				goType = strings.TrimPrefix(goType, "[]")
			}
			if strings.HasPrefix(goType, "*") {
				prefix += "*"
				goType = strings.TrimPrefix(goType, "*")
			}
			if _, isBt := protoTypeMap[goType]; isBt {
				return prefix + goType
			}
			if s := FindStruct(pkg, goType); s != nil {
				return prefix + pkg.Name + "." + goType
			}
			if dep != nil {
				if nameSlice := strings.Split(goType, "."); len(nameSlice) > 1 {
					if pkg, isDep := dep[nameSlice[0]]; isDep {
						if s := FindStruct(pkg, nameSlice[1]); s != nil {
							return prefix + pkg.Name + "." + s.Name
						}
					}
				}
			}
			return goType
		},
		"newType": func(goType string) string {
			var hasPointer bool
			if strings.HasPrefix(goType, "*") {
				hasPointer = true
				goType = strings.TrimPrefix(goType, "*")
			}
			if _, isBt := protoTypeMap[goType]; isBt {
				return goType
			}
			if s := FindStruct(pkg, goType); s != nil {
				if hasPointer {
					return "&" + pkg.Name + "." + goType + "{}"
				}
				return pkg.Name + "." + goType + "{}"
			}
			if dep != nil {
				if nameSlice := strings.Split(goType, "."); len(nameSlice) > 1 {
					if pkg, isDep := dep[nameSlice[0]]; isDep {
						if s := FindStruct(pkg, nameSlice[1]); s != nil {
							if hasPointer {
								return "&" + pkg.Name + "." + s.Name + "{}"
							}
							return pkg.Name + "." + s.Name + "{}"
						}
					}
				}
			}
			return goType
		},
		"toPbType": func(goType string) string {
			prefix := ""
			if strings.HasPrefix(goType, "[]") {
				prefix = "[]"
				goType = strings.TrimPrefix(goType, "[]")
			}
			if strings.HasPrefix(goType, "*") {
				prefix += "*"
				goType = strings.TrimPrefix(goType, "*")
			}
			if _, isBt := protoTypeMap[goType]; isBt {
				return prefix + goType
			}
			if s := FindStruct(pkg, goType); s != nil {
				return prefix + "pb_" + pkg.Name + "_v1." + goType
			}
			if dep != nil {
				if nameSlice := strings.Split(goType, "."); len(nameSlice) > 1 {
					if pkg, isDep := dep[nameSlice[0]]; isDep {
						if s := FindStruct(pkg, nameSlice[1]); s != nil {
							return prefix + "pb_" + pkg.Name + "_v1." + s.Name
						}
					}
				}
			}
			return goType
		},
		"newPbType": func(goType string) string {
			var hasPointer bool
			if strings.HasPrefix(goType, "*") {
				hasPointer = true
				goType = strings.TrimPrefix(goType, "*")
			}
			if _, isBt := protoTypeMap[goType]; isBt {
				if hasPointer {
					return goType
				}
			}
			if s := FindStruct(pkg, goType); s != nil {
				if hasPointer {
					return "&pb_" + pkg.Name + "_v1." + goType + "{}"
				}
				return "pb_" + pkg.Name + "_v1." + goType + "{}"
			}
			if dep != nil {
				if nameSlice := strings.Split(goType, "."); len(nameSlice) > 1 {
					if pkg, isDep := dep[nameSlice[0]]; isDep {
						if s := FindStruct(pkg, nameSlice[1]); s != nil {
							if hasPointer {
								return "&pb_" + pkg.Name + "_v1." + s.Name + "{}"
							}
							return "pb_" + pkg.Name + "_v1." + s.Name + "{}"
						}
					}
				}
			}
			return goType
		},
		"isSlice": func(goType string) bool {
			return strings.HasPrefix(goType, "[]")
		},
	})
	t, err = t.Parse(gsrvTemplate)
	if err != nil {
		return err
	}
	if err := t.Execute(f, pkg); err != nil {
		return err
	}

	return nil
}

// gsrvTemplate generate grpc server impl
const gsrvTemplate = `

type {{.Name}}Gsrv struct {
	pb_{{.Name}}_v1.Unimplemented{{.Name | toFulle}}GsrvServer
}

func New{{.Name | toFulle}}Gsrv() *{{.Name}}Gsrv {
	return &{{.Name}}Gsrv{}
}

{{range .Structs}}{{$struct := .}}{{range .Methods}}{{if eq .Type 0}}
func (u *{{$.Name}}Gsrv) {{$struct.Name}}{{.Name}}(ctx context.Context, in *anypb.Any) (out *anypb.Any, err error) {
	gm := mrz.ToTypedModel[*pb_{{$.Name}}_v1.{{$struct.Name}}, *structpb.Struct](in)
	m := mrz.GetData[*{{$struct.Name | toType}}](gm)
	res := mrz.NewTypedRes[*pb_{{$.Name}}_v1.{{$struct.Name}}, *structpb.Value]()
	{{if .Rets}}{{$ret := (index .Rets 0)}}var resData {{$ret.Type | toType}}
	resData, err = m.{{.Name}}(ctx{{if .Args}}, {{$rl := (len .Args)}}{{range $index,$arg := .Args}}mrz.GetArgs[{{$arg.Type | toType}}](gm,"{{$arg.Name | toCamel}}"){{if lt $index $rl}}, {{end}}{{end}}{{end}})
	{{else}}err = m.{{.Name}}(ctx{{if .Args}}, {{$rl := (len .Args)}}{{range $index,$arg := .Args}}mrz.GetArgs[{{$arg.Type | toType}}](gm,"{{$arg.Name | toCamel}}"){{if lt $index $rl}}, {{end}}{{end}}{{end}})
	{{end}}if err != nil {
		return nil, err
	}
	mrz.SetResData(res, m)
	{{if .Rets}}{{$ret := (index .Rets 0)}}{{if isSlice $ret.Type}}mrz.SetResRespList(res, resData){{else}}mrz.SetResResp(res, resData){{end}}{{else}}mrz.SetResRespNil(res){{end}}
	return res.ToAny(), nil
}
{{else if eq .Type 3}}type {{$.Name | toFulle}}{{$struct.Name}}{{.Name}}Stream struct {
	stream pb_{{$.Name}}_v1.{{$.Name | toFulle}}Gsrv_{{$struct.Name}}{{.Name}}Server
	m      *{{$.Name}}.{{$struct.Name}}
}
func (s *{{$.Name | toFulle}}{{$struct.Name}}{{.Name}}Stream) Context() context.Context {
	return s.stream.Context()
}
{{if .Rets}}{{else}}func (s *{{$.Name | toFulle}}{{$struct.Name}}{{.Name}}Stream) Send({{if .Args}}v {{(index .Args 0).Type | toType}}{{else}}_ *gs.Null{{end}}) error {
	res := mrz.NewTypedRes[*pb_{{$.Name}}_v1.{{$struct.Name}}, {{if .Args}}{{(index .Args 0).Type | toPbType}}{{else}}*anypb.Any{{end}}]()
	// data
	res.Data = new(pb_{{$.Name}}_v1.{{$struct.Name}})
	jd, err := sjson.Marshal(s.m)
	if err != nil {
		return err
	}
	err = sjson.Unmarshal(jd, res.Data)
	if err != nil {
		return err
	}
	// resp
	{{if .Args}}{{$arg := (index .Args 0)}}respByt, _ := sjson.Marshal(v)
	newResp := {{$arg.Type | newPbType}}
	err = sjson.Unmarshal(respByt, newResp)
	if err != nil {
		return err
	}
	res.Resp = newResp
	{{else}}null := structpb.NewNullValue()
	resp, _ := anypb.New(null)
	res.Resp = resp{{end}}
	return s.stream.Send(res.ToAny())
}
func (s *{{$.Name | toFulle}}{{$struct.Name}}{{.Name}}Stream) Recv() ({{if .Args}}{{(index .Args 0).Type | toType}}{{else}}*gs.Null{{end}}, error) {
	in, err := s.stream.Recv()
	if err != nil {
		return nil, err
	}
	req := mrz.ToTypedModel[*pb_{{$.Name}}_v1.{{$struct.Name}}, {{if .Args}}{{(index .Args 0).Type | toPbType}}{{else}}*anypb.Any{{end}}](in)
	jd, err := sjson.Marshal(req.Data)
	if err != nil {
		return nil, err
	}
	err = sjson.Unmarshal(jd, s.m)
	{{if .Args}}{{$arg := (index .Args 0)}}argsByt, _ := sjson.Marshal(req.Args)
	newArgs := {{$arg.Type | newType}}
	err = sjson.Unmarshal(argsByt, newArgs)
	return newArgs, err
	{{else}}return nil, err{{end}}
}
{{end}}
func (s *{{$.Name}}Gsrv) {{$struct.Name}}{{.Name}}(stream pb_{{$.Name}}_v1.{{$.Name | toFulle}}Gsrv_{{$struct.Name}}{{.Name}}Server) error {
	gsStream := &{{$.Name | toFulle}}{{$struct.Name}}{{.Name}}Stream{stream, &{{$.Name}}.{{$struct.Name}}{} }
	return gsStream.m.{{.Name}}(gsStream)
}
{{end}}{{end}}{{end}}
`

// GenerateTSCode generate ts code
func GenerateTSCode(path string, pkg *Package, dep map[string]*Package) error {

	f, err := os.Create(filepath.Join(path, fmt.Sprintf("%s.ts", sjson.ToSnackedName(pkg.Name))))
	if err != nil {
		return err
	}
	defer f.Close()

	{
		f.WriteString(fmt.Sprintln("// Code generated by github.com/tinkler/mqttadmin; DO NOT EDIT."))
	}

	var (
		usedDepStruct = make(map[string]map[string]bool)
	)
	for _, s := range pkg.Structs {
		fields := s.Fields
		for _, m := range s.Methods {
			fields = append(fields, m.Args...)
			fields = append(fields, m.Rets...)
		}
		for _, f := range fields {
			typ := f.Type
		FIND:
			typ = strings.TrimPrefix(typ, "*")
			if _, isBt := tsTypeMap[typ]; !isBt {
				if FindStruct(pkg, typ) == nil {
					if dep != nil {
						if nameSlice := strings.Split(typ, "."); len(nameSlice) > 1 {
							if _, isDep := dep[nameSlice[0]]; isDep {
								if FindStruct(dep[nameSlice[0]], nameSlice[1]) == nil {
									return fmt.Errorf("type %s not found", typ)
								} else {
									if usedDepStruct[nameSlice[0]] == nil {
										usedDepStruct[nameSlice[0]] = make(map[string]bool)
									}
									usedDepStruct[nameSlice[0]][nameSlice[1]] = true
								}
							} else {
								if strings.HasPrefix(typ, "[]") {
									typ = strings.TrimPrefix(typ, "[]")
									goto FIND
								} else {
									return fmt.Errorf("package %s not found", nameSlice[0])
								}
							}
						}

					}
				}
			}
		}
	}
	if len(usedDepStruct) > 0 {
		for _, importName := range pkg.Imports {
			if _, ok := usedDepStruct[importName]; ok {
				f.WriteString(fmt.Sprintf("import { %s } from './%s';\n", strings.Join(func() []string {
					var s []string
					for _, ds := range dep[importName].Structs {
						if _, ok := usedDepStruct[importName][ds.Name]; ok {
							s = append(s, ds.Name)
						}
					}
					return s
				}(), ", "), importName))
			}
		}
	}

	if len(pkg.Structs) > 0 {
		t := template.Must(template.New("model").Funcs(template.FuncMap{
			"toType": func(goType string) string {
				suffix := ""
			FIND:
				goType = strings.TrimPrefix(goType, "*")
				if bt, isBt := tsTypeMap[goType]; isBt {
					return bt + suffix
				}
				if s := FindStruct(pkg, goType); s != nil {
					return s.Name + suffix
				}
				if dep != nil {
					if nameSlice := strings.Split(goType, "."); len(nameSlice) > 1 {
						if pkg, isDep := dep[nameSlice[0]]; isDep {
							if s := FindStruct(pkg, nameSlice[1]); s != nil {
								return s.Name + suffix
							}
						}
					}
				}
				if strings.HasPrefix(goType, "[]") {
					suffix += "[]"
					goType = strings.TrimPrefix(goType, "[]")
					goto FIND
				}

				return ""
			},
			"toCamel": func(s string) string {
				return cjson.ToCamel(s)
			},
			"toSnack": func(s string) string {
				return sjson.ToSnackedName(s)
			},
			"toMinus": func(s string) string {
				return strings.ReplaceAll(sjson.ToSnackedName(s), "_", "-")
			},
			"toDefault": func(s string) string {
				if strings.HasSuffix(s, "[]") {
					return "[]"
				}
				if bt, isBt := tsDefaultValue[tsTypeMap[s]]; isBt {
					return bt
				}
				s = strings.TrimPrefix(s, "*")
				if s := FindStruct(pkg, s); s != nil {
					return s.Name + "()"
				}
				if dep != nil {
					if sli := strings.Split(s, "."); len(sli) > 1 {
						if pkg, isDep := dep[sli[0]]; isDep {
							if s := FindStruct(pkg, sli[1]); s != nil {
								return s.Name + "()"
							}
						}
					}

				}
				return ""
			},
		}).Parse(tsModelTemplate))

		err = t.Execute(f, pkg)
		if err != nil {
			return err
		}
	}

	return nil
}

// typescript template
const tsModelTemplate = `{{$pkgName := .Name}}
{{range .Structs}}{{$struct := .}}
{{range .Comments}}/**
* {{.}}
*/
{{end}}export interface {{.Name}} {
	{{range .Fields}}
	{{range .Comments}}/**
	* {{.}}
	*/
	{{end}}{{.Name | toCamel}}: {{.Type | toType}};
	{{end}}
	{{range .Methods}}{{if eq .Type 0}}
	{{range .Comments}}/**
	* {{.}}
	*/
	{{end}}{{.Name | toCamel}}({{$rl := (len .Args)}}{{range $index,$arg := .Args}}{{$arg.Name | toCamel}}: {{$arg.Type | toType}}{{if lt $index $rl}}, {{end}}{{end}}): {{if ge (len .Rets) 1}}Promise<{{$ret := (index .Rets 0)}}{{$ret.Type | toType}}> {{else}}Promise<void>{{end}};
	{{end}}{{end}}
}
{{end}}

{{range .Structs}}{{$struct := .}}
{{range .Comments}}/**
* {{.}}
*/
{{end}}export function {{.Name}}(): {{.Name}} {
	
	return {
		{{range .Fields}}
		{{.Name | toCamel}}: {{.Type | toDefault}},
		{{end}}
		{{range .Methods}}{{if eq .Type 0}}
		{{.Name | toCamel}}({{range $index,$arg := .Args}}{{$arg.Name | toCamel}}: {{$arg.Type | toType}}, {{end}}): {{if ge (len .Rets) 1}}Promise<{{$ret := (index .Rets 0)}}{{$ret.Type | toType}}> {{else}}Promise<void>{{end}} {
			
			return post{{$struct.Name}}(this, '{{.Name | toMinus}}', { {{range $index,$arg := .Args}}{{$arg.Name | toCamel}}, {{end}} }){{if ge (len .Rets) 1}}.then((res: { data: any }) => res.data as {{$ret := (index .Rets 0)}}{{$ret.Type | toType}}){{end}};
			
		},
		{{end}}{{end}}
		
	};
	
}

// post data by restful api

function post{{.Name}}({{.Name | toCamel}}: {{.Name}}, method: string, args: {}): Promise<any> {
	const xhr = new XMLHttpRequest();
	xhr.open("POST", ` + "`/{{$pkgName}}//{{$struct.Name | toSnack}}/{{.Name | toSnack}}/${method}`" + `, true);
	xhr.setRequestHeader("Content-Type", "application/json");
	return new Promise((resolve, reject) => {
		xhr.onload = () => {
			if (xhr.status === 200) {
				resolve(xhr.response);
			} else {
				reject(new Error(xhr.statusText));
			}
		};
		xhr.onerror = () => {
			reject(new Error(xhr.statusText));
		};
		xhr.send(JSON.stringify({ data: {{.Name | toCamel}}, args }));
	});
}
{{end}}
`

func GenerateTSAngularDelonCode(path string, pkg *Package, dep map[string]*Package) error {
	var (
		serviceFile     *os.File
		serviceSpecFile *os.File
		modelFile       *os.File
	)
	serviceFile, err := os.Create(filepath.Join(path, fmt.Sprintf("%s.service.ts", sjson.ToSnackedName(pkg.Name))))
	if err != nil {
		return err
	}
	defer serviceFile.Close()

	serviceSpecFile, err = os.Create(filepath.Join(path, fmt.Sprintf("%s.spec.ts", sjson.ToSnackedName(pkg.Name))))
	if err != nil {
		return err
	}
	defer serviceSpecFile.Close()

	modelFile, err = os.Create(filepath.Join(path, fmt.Sprintf("%s.model.ts", sjson.ToSnackedName(pkg.Name))))
	if err != nil {
		return err
	}
	defer modelFile.Close()

	{
		doNotEdit := "// Code generated by github.com/tinkler/mqttadmin; DO NOT EDIT."
		serviceFile.WriteString(fmt.Sprintln(doNotEdit))
		serviceSpecFile.WriteString(fmt.Sprintln(doNotEdit))
		modelFile.WriteString(fmt.Sprintln(doNotEdit))
	}

	var (
		modelUsedDepStruct   = make(map[string]map[string]bool)
		serviceUsedDepStruct = make(map[string]map[string]bool)
	)
	// collect used dep struct of model
	for _, s := range pkg.Structs {
		fields := s.Fields
		for _, m := range s.Methods {
			fields = append(fields, m.Args...)
			fields = append(fields, m.Rets...)
		}
		for _, f := range fields {
			typ := f.Type
		MODELFIND:
			typ = strings.TrimPrefix(typ, "*")
			if _, isBt := tsTypeMap[typ]; !isBt {
				if FindStruct(pkg, typ) == nil {
					if dep != nil {
						if nameSlice := strings.Split(typ, "."); len(nameSlice) > 1 {
							if _, isDep := dep[nameSlice[0]]; isDep {
								if FindStruct(dep[nameSlice[0]], nameSlice[1]) == nil {
									return fmt.Errorf("type %s not found", typ)
								} else {
									if modelUsedDepStruct[nameSlice[0]] == nil {
										modelUsedDepStruct[nameSlice[0]] = make(map[string]bool)
									}
									modelUsedDepStruct[nameSlice[0]][nameSlice[1]] = true
								}
							} else {
								if strings.HasPrefix(typ, "[]") {
									typ = strings.TrimPrefix(typ, "[]")
									goto MODELFIND
								} else {
									return fmt.Errorf("package %s not found", nameSlice[0])
								}
							}
						}

					}
				}
			}
		}
	}
	if len(modelUsedDepStruct) > 0 {
		for _, importName := range pkg.Imports {
			if _, ok := modelUsedDepStruct[importName]; ok {
				modelFile.WriteString(fmt.Sprintf("import { %s } from './%s.model';\n", strings.Join(func() []string {
					var s []string
					for _, ds := range dep[importName].Structs {
						if _, ok := modelUsedDepStruct[importName][ds.Name]; ok {
							s = append(s, ds.Name)
						}
					}
					return s
				}(), ", "), importName))
			}
		}
	}

	// collect used dep struct of service
	for _, s := range pkg.Structs {
		var fields []Field
		for _, m := range s.Methods {
			fields = append(fields, m.Args...)
			fields = append(fields, m.Rets...)
		}
		for _, f := range fields {
			typ := f.Type
		FIND:
			typ = strings.TrimPrefix(typ, "*")
			if _, isBt := tsTypeMap[typ]; !isBt {
				if FindStruct(pkg, typ) == nil {
					if dep != nil {
						if nameSlice := strings.Split(typ, "."); len(nameSlice) > 1 {
							if _, isDep := dep[nameSlice[0]]; isDep {
								if FindStruct(dep[nameSlice[0]], nameSlice[1]) == nil {
									return fmt.Errorf("type %s not found", typ)
								} else {
									if serviceUsedDepStruct[nameSlice[0]] == nil {
										serviceUsedDepStruct[nameSlice[0]] = make(map[string]bool)
									}
									serviceUsedDepStruct[nameSlice[0]][nameSlice[1]] = true
								}
							} else {
								if strings.HasPrefix(typ, "[]") {
									typ = strings.TrimPrefix(typ, "[]")
									goto FIND
								} else {
									return fmt.Errorf("package %s not found", nameSlice[0])
								}
							}
						}

					}
				}
			}
		}
	}
	if len(serviceUsedDepStruct) > 0 {
		for _, importName := range pkg.Imports {
			if _, ok := serviceUsedDepStruct[importName]; ok {
				serviceFile.WriteString(fmt.Sprintf("import { %s } from './%s.model';\n", strings.Join(func() []string {
					var s []string
					for _, ds := range dep[importName].Structs {
						if _, ok := serviceUsedDepStruct[importName][ds.Name]; ok {
							s = append(s, ds.Name)
						}
					}
					return s
				}(), ", "), importName))
			}
		}
	}

	if len(pkg.Structs) > 0 {
		globalFuncMap := template.FuncMap{
			"toType": func(goType string) string {
				suffix := ""
			FIND:
				goType = strings.TrimPrefix(goType, "*")
				if bt, isBt := tsTypeMap[goType]; isBt {
					return bt + suffix
				}
				if s := FindStruct(pkg, goType); s != nil {
					return s.Name + suffix
				}
				if dep != nil {
					if nameSlice := strings.Split(goType, "."); len(nameSlice) > 1 {
						if pkg, isDep := dep[nameSlice[0]]; isDep {
							if s := FindStruct(pkg, nameSlice[1]); s != nil {
								return s.Name + suffix
							}
						}
					}
				}
				if strings.HasPrefix(goType, "[]") {
					suffix += "[]"
					goType = strings.TrimPrefix(goType, "[]")
					goto FIND
				}

				return ""
			},
			"toCamel": func(s string) string {
				return cjson.ToCamel(s)
			},
			"toSnack": func(s string) string {
				return sjson.ToSnackedName(s)
			},
			"toMinus": func(s string) string {
				return strings.ReplaceAll(sjson.ToSnackedName(s), "_", "-")
			},
			"toDefault": func(s string) string {
				if strings.HasPrefix(s, "[]") {
					return "[]"
				}
				if bt, isBt := tsDefaultValue[tsTypeMap[s]]; isBt {
					return bt
				}
				s = strings.TrimPrefix(s, "*")
				if s := FindStruct(pkg, s); s != nil {
					return "new " + s.Name + "(this.http)"
				}
				if dep != nil {
					if sli := strings.Split(s, "."); len(sli) > 1 {
						if pkg, isDep := dep[sli[0]]; isDep {
							if s := FindStruct(pkg, sli[1]); s != nil {
								return "new " + s.Name + "(this.http)"
							}
						}
					}
				}
				return ""
			},
			"firstUpper": func(s string) string {
				return strings.ToUpper(s[:1]) + s[1:]
			},
		}

		{
			customFuncMap := make(template.FuncMap)
			for k, v := range globalFuncMap {
				customFuncMap[k] = v
			}
			customFuncMap["respToType"] = func(goType string) string {
				isArray := strings.HasPrefix(goType, "[]")
				if isArray {
					goType = strings.TrimPrefix(goType, "[]")
				}
				goType = strings.TrimPrefix(goType, "*")
				if bt, isBt := tsTypeMap[goType]; isBt {
					if isArray {
						return bt + "[]"
					}
					return bt
				}
				return "any"
			}
			customFuncMap["respSet"] = func(goType string) string {
				isArray := strings.HasPrefix(goType, "[]")
				if isArray {
					goType = strings.TrimPrefix(goType, "[]")
				}
				if bt, isBt := tsTypeMap[goType]; isBt {
					if isArray {
						return "const resp = res.data.resp as []" + bt
					}
					return "const resp = res.data.resp as " + bt
				}
				goType = strings.TrimPrefix(goType, "*")
				if s := FindStruct(pkg, goType); s != nil {
					if isArray {
						content := "const resp: []" + s.Name + " = [];"
						content += "for(const item of res.data.resp) {"
						content += "const _new = new " + s.Name + "(this.http);"
						for _, f := range s.Fields {
							content += "_new." + cjson.ToCamel(f.Name) + " = item['" + sjson.ToSnackedName(f.Name) + "'];"
						}
						content += "resp.push(_new);"
						content += "}"
						return content
					}
					content := "const resp: " + s.Name + " = new " + s.Name + "(this.http);"
					for _, f := range s.Fields {
						content += "resp." + cjson.ToCamel(f.Name) + " = res.data.resp['" + sjson.ToSnackedName(f.Name) + "'];"
					}
					return content
				}
				return "const resp = res.data.resp"
			}
			t := template.Must(template.New("model").Funcs(customFuncMap).Parse(tsAngularDelonModelTemplate))
			err = t.Execute(modelFile, pkg)
			if err != nil {
				return err
			}
		}

		{

			t := template.Must(template.New("service").Funcs(globalFuncMap).Parse(tsAngularDelonServiceTemplate))
			err = t.Execute(serviceFile, pkg)
			if err != nil {
				return err
			}
		}

		{
			t := template.Must(template.New("serviceSpec").Funcs(globalFuncMap).Parse(tsAngularDelonServiceSpecTemplate))
			err = t.Execute(serviceSpecFile, pkg)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

const tsAngularDelonModelTemplate = `{{$pkgName := .Name}}

import { _HttpClient } from '@delon/theme';
import { modelUrlPrefix  } from './const';
{{range .Structs}}{{$struct := .}}
{{range .Comments}}/**
* {{.}}
*/
{{end}}export interface {{.Name}} {
	{{range .Fields}}
	{{range .Comments}}/**
	* {{.}}
	*/
	{{end}}{{.Name | toCamel}}: {{.Type | toType}};
	{{end}}
	{{range .Methods}}{{if eq .Type 0}}
	{{range .Comments}}/**
	* {{.}}
	*/
	{{end}}{{.Name | toCamel}}({{$rl := (len .Args)}}{{range $index,$arg := .Args}}{{$arg.Name | toCamel}}: {{$arg.Type | toType}}{{if lt $index $rl}}, {{end}}{{end}}): {{if ge (len .Rets) 1}}Promise<{{$ret := (index .Rets 0)}}{{$ret.Type | toType}}> {{else}}Promise<void>{{end}};
	{{end}}{{end}}
}

export class {{.Name}} {
	{{range .Fields}}
	{{range .Comments}}/**
	* {{.}}
	*/
	{{end}}{{.Name | toCamel}}: {{.Type | toType}} = {{.Type | toDefault}};
	{{end}}

	constructor(
		private http: _HttpClient,
	){}

	{{range .Methods}}{{if eq .Type 0}}
	{{range .Comments}}/**
	* {{.}}
	*/
	{{end}}{{.Name | toCamel}}({{range $index,$arg := .Args}}{{$arg.Name | toCamel}}: {{$arg.Type | toType}}, {{end}}): {{if ge (len .Rets) 1}}Promise<{{$ret := (index .Rets 0)}}{{$ret.Type | toType}}> {{else}}Promise<void>{{end}} {
		return new Promise((resolve, reject) => {
			this.http.post(` + "`" + `${modelUrlPrefix}/{{$pkgName}}/{{$struct.Name | toSnack}}/{{.Name | toMinus}}` + "`" + `, { data: this, args: { {{range $index,$arg := .Args}}{{$arg.Name | toSnack}}: {{$arg.Name | toCamel}}, {{end}} } }).subscribe({
				next: (res: { code: number; data: { data: any, resp: {{if ge (len .Rets) 1}}{{$ret := (index .Rets 0)}}{{$ret.Type | respToType}}{{else}}{}{{end}} }, message: string } ) => {
					if (res.code === 0) {
						{{range $struct.Fields}}this.{{.Name | toCamel}} = res.data.data['{{.Name | toSnack}}'];
						{{end}}
						{{if ge (len .Rets) 1}}{{$ret := (index .Rets 0)}}
						{{$ret.Type | respSet}}
						resolve(resp);
						{{else}}resolve();{{end}}
					} else {
						reject(res.message);
					}
				}, error: (err) => {
					reject(err);
				}
			});
		});
	}
	{{end}}{{end}}
}

{{end}}


`
const tsAngularDelonServiceTemplate = `{{$pkgName := .Name}}
import { Injectable } from '@angular/core';
import { {{range .Structs}}{{.Name}}, {{end}} } from './{{.Name | toMinus}}.model';
{{range .Imports}}{{if ne . $pkgName}}import { {{. | firstUpper}}Service  } from './{{. | toMinus}}.service';
{{end}}{{end}}
import { _HttpClient } from '@delon/theme';

@Injectable({
	providedIn: 'root'
})
export class {{.Name | firstUpper}}Service {
  
	constructor(
		private http: _HttpClient,
		{{range .Imports}}private {{. | toCamel}}Srv: {{. | firstUpper}}Service,
		{{end}}
		) { }

	{{range .Structs}}{{$struct := .}}
	{{range .Comments}}/**
	* {{.}}
	*/
	{{end}}new{{.Name}}(): {{.Name}} {
		return new {{.Name}}(this.http);
	}{{end}}
}
`

const tsAngularDelonServiceSpecTemplate = `{{$pkgName := .Name}}
import { TestBed } from '@angular/core/testing';

import { {{.Name | firstUpper}}Service } from './{{.Name | toMinus}}.service';

describe('{{.Name | firstUpper}}Service', () => {
  let service: {{.Name | firstUpper}}Service;

  beforeEach(() => {
    TestBed.configureTestingModule({});
    service = TestBed.inject({{.Name | firstUpper}}Service);
  });

  it('should be created', () => {
    expect(service).toBeTruthy();
  });
});

`

// GenerateDartCode generate dart code
func GenerateDartCode(path string, pkg *Package, dep map[string]*Package) error {
	f, err := os.Create(filepath.Join(path, fmt.Sprintf("%s.dart", sjson.ToSnackedName(pkg.Name))))
	if err != nil {
		return err
	}
	defer f.Close()

	{
		f.WriteString(fmt.Sprintln("// Code generated by github.com/tinkler/mqttadmin; DO NOT EDIT."))
		f.WriteString(fmt.Sprintln("import '../../http.dart';"))
		f.WriteString(fmt.Sprintln("import './const.dart';"))
	}
	var (
		usedDepStruct = make(map[string]map[string]bool)
	)
	for _, s := range pkg.Structs {
		fields := s.Fields
		for _, m := range s.Methods {
			fields = append(fields, m.Args...)
			fields = append(fields, m.Rets...)
		}
		for _, f := range fields {
			typ := f.Type
		FIND:
			typ = strings.TrimPrefix(typ, "*")
			if _, isBt := tsTypeMap[typ]; !isBt {
				if FindStruct(pkg, typ) == nil {
					if dep != nil {
						if nameSlice := strings.Split(typ, "."); len(nameSlice) > 1 {
							if _, isDep := dep[nameSlice[0]]; isDep {
								if FindStruct(dep[nameSlice[0]], nameSlice[1]) == nil {
									return fmt.Errorf("type %s not found", typ)
								} else {
									if usedDepStruct[nameSlice[0]] == nil {
										usedDepStruct[nameSlice[0]] = make(map[string]bool)
									}
									usedDepStruct[nameSlice[0]][nameSlice[1]] = true
								}
							} else {
								if strings.HasPrefix(typ, "[]") {
									typ = strings.TrimPrefix(typ, "[]")
									goto FIND
								} else {
									return fmt.Errorf("package %s not found", nameSlice[0])
								}
							}
						}

					}
				}
			}
		}
	}
	if len(usedDepStruct) > 0 {
		for _, importName := range pkg.Imports {
			if _, ok := usedDepStruct[importName]; ok {
				f.WriteString(fmt.Sprintf("import './%[1]s.dart' as $%[1]s show %[2]s;\n", importName, strings.Join(func() []string {
					var s []string
					for _, ds := range dep[importName].Structs {
						if _, ok := usedDepStruct[importName][ds.Name]; ok {
							s = append(s, ds.Name)
						}
					}
					return s
				}(), ", "), importName))
			}
		}
	}

	t := template.Must(template.New("model").Funcs(template.FuncMap{
		"toType": func(goType string) string {
			nullCheckSuffix := ""
			if strings.HasPrefix(goType, "*") {
				nullCheckSuffix = "?"
			}
			goType = strings.ReplaceAll(goType, "*", "")
			if typ := dartTypeMap[goType]; typ != "" {
				return typ + nullCheckSuffix
			}
			if strings.HasPrefix(goType, "[]") {
				var (
					resTypePre string
					resTypeSuf string
					typ        = goType
				)
				for strings.HasPrefix(typ, "[]") {
					resTypePre += "List<"
					resTypeSuf += ">"
					typ = strings.TrimPrefix(typ, "[]")
				}
				if typ := dartTypeMap[typ]; typ != "" {
					return fmt.Sprintf(resTypePre+"%s"+resTypeSuf+nullCheckSuffix, typ)
				}
				if s := FindStruct(pkg, typ); s != nil {
					return fmt.Sprintf(resTypePre+"%s"+resTypeSuf+nullCheckSuffix, typ)
				}
				if dep != nil {
					if nameSplice := strings.Split(typ, "."); len(nameSplice) > 1 {
						if pkg, isDep := dep[nameSplice[0]]; isDep {
							if FindStruct(pkg, nameSplice[1]) != nil {
								return fmt.Sprintf(resTypePre+"%s"+resTypeSuf+nullCheckSuffix, "$"+pkg.Name+"."+nameSplice[1])
							}
						}
					}
				}
				return fmt.Sprintf(resTypePre+"%s"+resTypeSuf+nullCheckSuffix, typ)
			}
			if typ := dartTypeMap[goType]; typ != "" {
				return typ + nullCheckSuffix
			}
			if s := FindStruct(pkg, goType); s != nil {
				return goType + nullCheckSuffix
			}
			if dep != nil {
				if nameSplice := strings.Split(goType, "."); len(nameSplice) > 1 {
					if pkg, isDep := dep[nameSplice[0]]; isDep {
						if FindStruct(pkg, nameSplice[1]) != nil {
							return "$" + pkg.Name + "." + nameSplice[1] + nullCheckSuffix
						}
					}
				}
			}
			return goType + nullCheckSuffix
		},
		"toCamel": func(s string) string {
			return cjson.ToCamel(s)
		},
		"toSnack": func(s string) string {
			return sjson.ToSnackedName(s)
		},
		"toMinus": func(s string) string {
			return strings.ReplaceAll(sjson.ToSnackedName(s), "_", "-")
		},
		"toDefault": func(goType string) string {
			if strings.HasPrefix(goType, "*") {
				return ""
			}
			goType = strings.ReplaceAll(goType, "*", "")
			if typ := dartDefaultValue[dartTypeMap[goType]]; typ != "" {
				return " = " + typ
			}
			if strings.HasPrefix(goType, "[]") {
				return " = " + "[]"
			}
			if dep != nil {
				if nameSplice := strings.Split(goType, "."); len(nameSplice) > 1 {
					if pkg, isDep := dep[nameSplice[0]]; isDep {
						if FindStruct(pkg, nameSplice[1]) != nil {
							return " = $" + pkg.Name + "." + nameSplice[1] + "()"
						}
					}
				}
			}
			return " = " + goType + "()"
		},
		"asToJson": func(goType string, name string) string {
			if typ := dartTypeMap[goType]; typ != "" {
				return ""
			}
			if strings.HasPrefix(goType, "[]") {
				goType = strings.TrimPrefix(goType, "[]")
				if typ := dartTypeMap[goType]; typ != "" {
					return ""
				}
				return ".map((e) => e.toJson()).toList()"
			}
			if strings.HasPrefix(goType, "*") {
				return fmt.Sprintf(" != null ? %[1]s!.toJson() : null", name)
			}
			return name + ".toJson()"
		},
		"fromJson": func(goType string, name string) string {
			goType = strings.ReplaceAll(goType, "*", "")
			if typ := dartTypeMap[goType]; typ != "" {
				return ""
			}
			if strings.HasPrefix(goType, "[]") {
				goType = strings.TrimPrefix(goType, "[]")
				if typ := dartTypeMap[goType]; typ != "" {
					return fmt.Sprintf(" == null ? [] : (json[\"%s\"] as List<dynamic>).map((e) => e as %s).toList()", name, typ)
				}
				if s := FindStruct(pkg, goType); s != nil {
					return fmt.Sprintf(" == null ? [] : (json[\"%s\"] as List<dynamic>).map((e) => %s.fromJson(e)).toList()", name, goType)
				}
				if dep != nil {
					if nameSplice := strings.Split(goType, "."); len(nameSplice) > 1 {
						if pkg, isDep := dep[nameSplice[0]]; isDep {
							if FindStruct(pkg, nameSplice[1]) != nil {
								return fmt.Sprintf(" == null ? [] : (json[\"%s\"] as List<dynamic>).map((e) => $"+"%s."+nameSplice[1]+".fromJson(e)).toList()", name, pkg.Name)
							}
						}
					}
				}
				return fmt.Sprintf(" == null ? [] : (json[\"%s\"] as List<dynamic>).map((e) => %s.fromJson(e)).toList()", name, strings.TrimPrefix(goType, "[]"))
			}
			if s := FindStruct(pkg, goType); s != nil {
				return fmt.Sprintf(" == null ? %[1]s() : %[1]s.fromJson(json[\"%[2]s\"])", goType, name)
			}
			if dep != nil {
				if nameSplice := strings.Split(goType, "."); len(nameSplice) > 1 {
					if pkg, isDep := dep[nameSplice[0]]; isDep {
						if FindStruct(pkg, nameSplice[1]) != nil {
							return fmt.Sprintf(" == null ? %[1]s() : %[1]s.fromJson(json[\"%[2]s\"])", "$"+pkg.Name+"."+nameSplice[1], name)
						}
					}
				}
			}
			return ".fromJson($s)"
		},
		"returnArgs": func(goType string) string {
			goType = strings.ReplaceAll(goType, "*", "")
			if typ := dartTypeMap[goType]; typ != "" {
				return "response.data['data']['resp']"
			}
			if strings.HasPrefix(goType, "[]") {
				goType = strings.TrimPrefix(goType, "[]")
				if typ := dartTypeMap[goType]; typ != "" {
					return "response.data['data']['resp'] as List<" + typ + ">"
				}
				if s := FindStruct(pkg, goType); s != nil {
					return "(response.data['data']['resp'] as List<dynamic>).map((e) => " + goType + ".fromJson(e)).toList()"
				}
				if dep != nil {
					if nameSplice := strings.Split(goType, "."); len(nameSplice) > 1 {
						if pkg, isDep := dep[nameSplice[0]]; isDep {
							if FindStruct(pkg, nameSplice[1]) != nil {
								return "(response.data['data']['resp'] as List<dynamic>).map((e) => $" + pkg.Name + "." + nameSplice[1] + ".fromJson(e)).toList()"
							}
						}
					}
				}
			}
			if s := FindStruct(pkg, goType); s != nil {
				return goType + ".fromJson(response.data['data']['resp'])"
			}
			if dep != nil {
				if nameSplice := strings.Split(goType, "."); len(nameSplice) > 1 {
					if pkg, isDep := dep[nameSplice[0]]; isDep {
						if FindStruct(pkg, nameSplice[1]) != nil {
							return "$" + pkg.Name + "." + nameSplice[1] + ".fromJson(response.data['data']['resp'])"
						}
					}
				}
			}
			return "response.data['data']['resp']"
		},
		"returnDefault": func(goType string) string {
			if strings.HasPrefix(goType, "*") {
				return "return null"
			}
			goType = strings.ReplaceAll(goType, "*", "")
			if typ := dartDefaultValue[dartTypeMap[goType]]; typ != "" {
				return "return " + typ
			}
			if strings.HasPrefix(goType, "[]") {
				return "return " + "[]"
			}
			if dep != nil {
				if nameSplice := strings.Split(goType, "."); len(nameSplice) > 1 {
					if pkg, isDep := dep[nameSplice[0]]; isDep {
						if FindStruct(pkg, nameSplice[1]) != nil {
							return "return  $" + pkg.Name + "." + nameSplice[1] + "()"
						}
					}
				}
			}
			return "return " + goType + "()"
		},
	}).Parse(dartModelTemplate))

	return t.Execute(f, pkg)
}

// dart template
var dartModelTemplate = `{{$name := .Name}}
{{range .Structs}}{{$struct := .}}
class {{.Name}} {
	{{range .Fields}}
	{{.Type | toType}} {{.Name | toCamel}}{{.Type | toDefault}};
	{{end}}
	{{range .Methods}}{{if eq .Type 0}}{{if .Comments}}
	{{range .Comments}}/// {{.}}
	{{end}}{{end}}Future<{{if .Rets}}{{(index .Rets 0).Type | toType}}{{else}}void{{end}}> {{.Name | toCamel}}(
		{{range .Args}}{{.Type | toType}} {{.Name | toCamel}},
		{{end}}
	) async {
		var response = await D.instance.dio.post('$modelUrlPrefix/{{$name}}/{{$struct.Name | toSnack}}/{{.Name | toMinus}}', data: {
			"data": toJson(),
			"args": { {{range .Args}}"{{.Name | toSnack}}": {{.Name | toCamel}},{{end}} }
		});
		if (response.data['code'] == 0) {
			var respModel = {{$struct.Name}}.fromJson(response.data['data']['data']);
			assign(respModel);
			{{if .Rets}}if (response.data['data']['resp'] != null) {
				return {{(index .Rets 0).Type | returnArgs}};
			} else {
				{{(index .Rets 0).Type | returnDefault}};
			}
			{{end}}
		}
		{{if .Rets}}{{(index .Rets 0).Type | returnDefault}};
		{{end}}
	}
	{{end}}{{end}}
	{{.Name}}();

	assign({{.Name}} other) {
		{{range .Fields}}
		{{.Name | toCamel}} = other.{{.Name | toCamel}};
		{{end}}
	}

	Map<String, dynamic> toJson() {
		return {
			{{range .Fields}}
			"{{.JSON}}": {{.Name | toCamel}}{{asToJson .Type (.Name | toCamel)}},
			{{end}}
		};
	}
	{{.Name}}.fromJson(Map<String, dynamic> json) {
		{{range .Fields}}
		{{.Name | toCamel}} = json["{{.JSON}}"]{{fromJson .Type .JSON}};
		{{end}}
	}
}
{{end}}

`

// GenerateSwiftCode generate swift code
func GenerateSwiftCode(path string, pkg *Package) error {
	t := template.Must(template.New("model").Funcs(template.FuncMap{
		"toType": func(goType string) string {
			return swiftTypeMap[goType]
		},
		"toCamel": func(s string) string {
			return cjson.ToCamel(s)
		},
		"toDefault": func(s string) string {
			return swiftDefaultValue[swiftTypeMap[s]]
		},
	}).Parse(swiftModelTemplate))
	f, err := os.Create(filepath.Join(path, cjson.SnakeCaseToFullCamelCase(pkg.Name)+".swift"))
	if err != nil {
		return err
	}
	defer f.Close()
	return t.Execute(f, pkg)
}

// swift template
var swiftModelTemplate = `// Code generated by github.com/tinkler/mqttadmin; DO NOT EDIT.
{{range .Structs}}
struct {{.Name}} {
	{{range .Fields}}
	var {{.Name | toCamel}}: {{.Type | toType}};
	{{end}}
	{{range .Methods}}{{if eq .Type 0}}
	func {{.Name | toCamel}}({{range .Args}}{{.Name | toCamel}}: {{.Type | toType}}, {{end}}) -> {{if .Rets}}{{range .Rets}}{{.Type | toType}}, {{end}} {{else}}Void{{end}} {
		
	}
	{{end}}{{end}}
}
{{end}}
`
