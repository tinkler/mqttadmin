package parser

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/tinkler/mqttadmin/pkg/jsonz/cjson"
	"github.com/tinkler/mqttadmin/pkg/jsonz/sjson"
)

// GenerateRoutes generate routes for package using template.
func GenerateRoutes(path string, pkg *Package, dep map[string]*Package) error {
	f, err := os.Create(filepath.Join(path, "pkg", "route", fmt.Sprintf("%s.go", pkg.Name)))
	if err != nil {
		return err
	}
	defer f.Close()

	{
		f.WriteString(fmt.Sprintln("// Code generated by github.com/tinkler/mqttadmin; DO NOT EDIT."))
		f.WriteString(fmt.Sprintln("package route"))
	}

	var (
		usedDepStruct = make(map[string]map[string]bool)
		hasMethods    bool
	)
	for _, s := range pkg.Structs {
		fields := s.Fields
		for _, m := range s.Methods {
			fields = append(fields, m.Args...)
			fields = append(fields, m.Rets...)
			hasMethods = true
		}
		for _, f := range fields {
			typ := f.Type
		FIND:
			typ = strings.TrimPrefix(typ, "*")
			if _, isBt := tsTypeMap[typ]; !isBt {
				if FindStruct(pkg, typ) == nil {
					if dep != nil {
						if nameSlice := strings.Split(typ, "."); len(nameSlice) > 1 {
							if _, isDep := dep[nameSlice[0]]; isDep {
								if FindStruct(dep[nameSlice[0]], nameSlice[1]) == nil {
									return fmt.Errorf("type %s not found", typ)
								} else {
									if usedDepStruct[nameSlice[0]] == nil {
										usedDepStruct[nameSlice[0]] = make(map[string]bool)
									}
									usedDepStruct[nameSlice[0]][nameSlice[1]] = true
								}
							} else {
								if strings.HasPrefix(typ, "[]") {
									typ = strings.TrimPrefix(typ, "[]")
									goto FIND
								} else {
									return fmt.Errorf("package %s not found", nameSlice[0])
								}
							}
						}

					}
				}
			}
		}
	}

	{
		f.WriteString(fmt.Sprintln("import ("))
		if hasMethods {
			f.WriteString(fmt.Sprintln("\t\"net/http\""))
			f.WriteString(fmt.Sprintln())
		}

		f.WriteString(fmt.Sprintln("\t\"github.com/go-chi/chi/v5\""))
		if hasMethods {
			f.WriteString(fmt.Sprintln("\t\"github.com/tinkler/mqttadmin/pkg/jsonz/sjson\""))
			f.WriteString(fmt.Sprintf("\t\"github.com/tinkler/mqttadmin/pkg/model/%s\"\n", pkg.Name))
		}
		for _, importName := range pkg.Imports {
			if _, used := usedDepStruct[importName]; used {
				f.WriteString(fmt.Sprintf("\t\"github.com/tinkler/mqttadmin/pkg/model/%s\"\n", importName))
			}
		}
		f.WriteString(fmt.Sprintln(")"))
	}

	{
		t := template.Must(template.New("model").Funcs(template.FuncMap{
			"toType": func(typ string) string {
				if _, isBt := tsTypeMap[typ]; isBt {
					return typ
				}
				if sli := strings.Split(typ, "."); len(sli) > 1 {
					return typ
				}
				if strings.HasPrefix(typ, "*") {
					return fmt.Sprintf("*%s.%s", pkg.Name, strings.TrimPrefix(typ, "*"))
				}
				return fmt.Sprintf("%s.%s", pkg.Name, typ)
			},
			"toSnack": func(s string) string {
				return sjson.ToSnackedName(s)
			},
			"toFulle": func(s string) string {
				return cjson.SnakeCaseToFullCamelCase(s)
			},
			"toMinus": func(s string) string {
				return strings.ReplaceAll(sjson.ToSnackedName(s), "_", "-")
			},
		}).Parse(goTemplate))
		if err := t.Execute(f, pkg); err != nil {
			return err
		}
	}

	return nil
}

// go route template
const goTemplate = `
func Routes{{.Name | toFulle}}(m *chi.Mux) {
	m.Route("/{{.Name}}", func(r chi.Router) {
		{{range .Structs}}{{$struct := .}}{{range .Methods}}
		r.Post("/{{$struct.Name | toSnack}}/{{.Name | toMinus}}", func(w http.ResponseWriter, r *http.Request) {
			m := Model[*{{$struct.Name | toType}}, {{if .Args}}struct{ {{range .Args}}{{.Name | toFulle}} {{.Type}} }{{end}}{{else}}any{{end}}]{}
			err := sjson.Bind(r, &m)
			if err != nil {
				http.Error(w, err.Error(), http.StatusBadRequest)
				return
			}
			{{if ge (len .Rets) 1}}res := Res[{{(index .Rets 0).Type | toType}}]{}
			{{else}}res := Res[struct{}]{}
			{{end}}
			{{if .Args}}{{if ge (len .Rets) 1}}res.Data, err = m.Data.{{.Name}}(r.Context(){{if .Args}}, {{$rl := (len .Args)}}{{range $index,$arg := .Args}}m.Args.{{$arg.Name | toFulle}}{{if lt $index $rl}}, {{end}}{{end}}{{end}})
			{{else}}err = m.Data.{{.Name}}(r.Context(){{if .Args}}, {{$rl := (len .Args)}}{{range $index,$arg := .Args}}m.Args.{{$arg.Name | toFulle}}{{if lt $index $rl}}, {{end}}{{end}}{{end}})
			{{end}}{{else}}{{if ge (len .Rets) 1}}res.Data, err = m.Data.{{.Name}}(r.Context())
			{{else}}err = m.Data.{{.Name}}(r.Context())
			{{end}}{{end}}
			if err != nil {
				http.Error(w, err.Error(), http.StatusInternalServerError)
				return
			}
			w.Header().Set("Content-Type", "application/json")
			byt, _ := sjson.Marshal(res)
			_, _ = w.Write(byt)

		}){{end}}{{end}}
	})
}
`

// GenerateTSCode generate ts code
func GenerateTSCode(path string, pkg *Package, dep map[string]*Package) error {

	f, err := os.Create(filepath.Join(path, "static", "ts", fmt.Sprintf("%s.ts", sjson.ToSnackedName(pkg.Name))))
	if err != nil {
		return err
	}
	defer f.Close()

	{
		f.WriteString(fmt.Sprintln("// Code generated by github.com/tinkler/mqttadmin; DO NOT EDIT."))
	}

	var (
		usedDepStruct = make(map[string]map[string]bool)
	)
	for _, s := range pkg.Structs {
		fields := s.Fields
		for _, m := range s.Methods {
			fields = append(fields, m.Args...)
			fields = append(fields, m.Rets...)
		}
		for _, f := range fields {
			typ := f.Type
		FIND:
			typ = strings.TrimPrefix(typ, "*")
			if _, isBt := tsTypeMap[typ]; !isBt {
				if FindStruct(pkg, typ) == nil {
					if dep != nil {
						if nameSlice := strings.Split(typ, "."); len(nameSlice) > 1 {
							if _, isDep := dep[nameSlice[0]]; isDep {
								if FindStruct(dep[nameSlice[0]], nameSlice[1]) == nil {
									return fmt.Errorf("type %s not found", typ)
								} else {
									if usedDepStruct[nameSlice[0]] == nil {
										usedDepStruct[nameSlice[0]] = make(map[string]bool)
									}
									usedDepStruct[nameSlice[0]][nameSlice[1]] = true
								}
							} else {
								if strings.HasPrefix(typ, "[]") {
									typ = strings.TrimPrefix(typ, "[]")
									goto FIND
								} else {
									return fmt.Errorf("package %s not found", nameSlice[0])
								}
							}
						}

					}
				}
			}
		}
	}
	if len(usedDepStruct) > 0 {
		for _, importName := range pkg.Imports {
			if _, ok := usedDepStruct[importName]; ok {
				f.WriteString(fmt.Sprintf("import { %s } from './%s';\n", strings.Join(func() []string {
					var s []string
					for _, ds := range dep[importName].Structs {
						if _, ok := usedDepStruct[importName][ds.Name]; ok {
							s = append(s, ds.Name)
						}
					}
					return s
				}(), ", "), importName))
			}
		}
	}

	if len(pkg.Structs) > 0 {
		t := template.Must(template.New("model").Funcs(template.FuncMap{
			"toType": func(goType string) string {
				suffix := ""
			FIND:
				goType = strings.TrimPrefix(goType, "*")
				if bt, isBt := tsTypeMap[goType]; isBt {
					return bt + suffix
				}
				if s := FindStruct(pkg, goType); s != nil {
					return s.Name + suffix
				}
				if dep != nil {
					if nameSlice := strings.Split(goType, "."); len(nameSlice) > 1 {
						if pkg, isDep := dep[nameSlice[0]]; isDep {
							if s := FindStruct(pkg, nameSlice[1]); s != nil {
								return s.Name + suffix
							}
						}
					}
				}
				if strings.HasPrefix(goType, "[]") {
					suffix += "[]"
					goType = strings.TrimPrefix(goType, "[]")
					goto FIND
				}

				return ""
			},
			"toCamel": func(s string) string {
				return cjson.ToCamel(s)
			},
			"toSnack": func(s string) string {
				return sjson.ToSnackedName(s)
			},
			"toMinus": func(s string) string {
				return strings.ReplaceAll(sjson.ToSnackedName(s), "_", "-")
			},
			"toDefault": func(s string) string {
				if strings.HasSuffix(s, "[]") {
					return "[]"
				}
				if bt, isBt := tsDefaultValue[tsTypeMap[s]]; isBt {
					return bt
				}
				s = strings.TrimPrefix(s, "*")
				if s := FindStruct(pkg, s); s != nil {
					return s.Name + "()"
				}
				if dep != nil {
					if pkg, isDep := dep[strings.Split(s, ".")[0]]; isDep {
						if s := FindStruct(pkg, s); s != nil {
							return s.Name + "()"
						}
					}
				}
				return ""
			},
		}).Parse(tsModelTemplate))

		err = t.Execute(f, pkg)
		if err != nil {
			return err
		}
	}

	return nil
}

// typescript template
const tsModelTemplate = `{{$pkgName := .Name}}
{{range .Structs}}
export interface {{.Name}} {
	{{range .Fields}}
	{{.Name | toCamel}}: {{.Type | toType}};
	{{end}}
	{{range .Methods}}
	{{.Name | toCamel}}({{$rl := (len .Args)}}{{range $index,$arg := .Args}}{{$arg.Name | toCamel}}: {{$arg.Type | toType}}{{if lt $index $rl}}, {{end}}{{end}}): {{if ge (len .Rets) 1}}Promise<{{$ret := (index .Rets 0)}}{{$ret.Type | toType}}> {{else}}Promise<void>{{end}};
	{{end}}
}
{{end}}

{{range .Structs}}{{$structName := .Name}}
export function {{.Name}}(): {{.Name}} {
	
	return {
		
		{{range .Fields}}

		{{.Name | toCamel}}: {{.Type | toDefault}},
		{{end}}

		{{range .Methods}}

		{{.Name | toCamel}}({{$rl := (len .Args)}}{{range $index,$arg := .Args}}{{$arg.Name | toCamel}}: {{$arg.Type | toType}}{{if lt $index $rl}}, {{end}}{{end}}): {{if ge (len .Rets) 1}}Promise<{{$ret := (index .Rets 0)}}{{$ret.Type | toType}}> {{else}}Promise<void>{{end}} {
			
			return post{{$structName}}(this, '{{.Name | toMinus}}', {}){{if ge (len .Rets) 1}}.then((res: { data: any }) => res.data as {{$ret := (index .Rets 0)}}{{$ret.Type | toType}}){{end}};
			
		},
		{{end}}
		
	};
	
}

// post data by restful api

function post{{.Name}}({{.Name | toCamel}}: {{.Name}}, method: string, arg: {}): Promise<any> {
	const xhr = new XMLHttpRequest();
	xhr.open("POST", ` + "`/{{$pkgName}}/{{.Name | toSnack}}/${method}`" + `, true);
	xhr.setRequestHeader("Content-Type", "application/json");
	return new Promise((resolve, reject) => {
		xhr.onload = () => {
			if (xhr.status === 200) {
				resolve(xhr.response);
			} else {
				reject(new Error(xhr.statusText));
			}
		};
		xhr.onerror = () => {
			reject(new Error(xhr.statusText));
		};
		xhr.send(JSON.stringify({ data: {{.Name | toCamel}}, arg: arg }));
	});
}
{{end}}
`

// GenerateDartCode generate dart code
func GenerateDartCode(path string, pkg *Package) error {
	t := template.Must(template.New("model").Funcs(template.FuncMap{
		"toType": func(goType string) string {
			return dartTypeMap[goType]
		},
		"toCamel": func(s string) string {
			return cjson.ToCamel(s)
		},
		"toDefault": func(s string) string {
			return dartDefaultValue[dartTypeMap[s]]
		},
	}).Parse(dartModelTemplate))
	f, err := os.Create(filepath.Join(path, "static", "dart", fmt.Sprintf("%s.dart", sjson.ToSnackedName(pkg.Name))))
	if err != nil {
		return err
	}
	defer f.Close()
	return t.Execute(f, pkg)
}

// dart template
var dartModelTemplate = `// Code generated by github.com/tinkler/mqttadmin; DO NOT EDIT.
{{range .Structs}}
class {{.Name}} {
	{{range .Fields}}
	{{.Type | toType}} {{.Name | toCamel}} = {{.Type | toDefault}};
	{{end}}
	{{range .Methods}}
	Future<{{if .Rets}}{{$rl := (len .Rets)}}{{range $index,$ret := .Rets}}{{$ret.Type | toType}}{{if lt $index $rl}}, {{end}}{{end}} {{else}}void{{end}}> {{.Name | toCamel}}({{range .Args}}{{.Type | toType}} {{.Name | toCamel}}, {{end}}) async {
		
	}
	{{end}}
}
{{end}}

`

// GenerateSwiftCode generate swift code
func GenerateSwiftCode(path string, pkg *Package) error {
	t := template.Must(template.New("model").Funcs(template.FuncMap{
		"toType": func(goType string) string {
			return swiftTypeMap[goType]
		},
		"toCamel": func(s string) string {
			return cjson.ToCamel(s)
		},
		"toDefault": func(s string) string {
			return swiftDefaultValue[swiftTypeMap[s]]
		},
	}).Parse(swiftModelTemplate))
	f, err := os.Create(filepath.Join(path, "static", "swift", cjson.SnakeCaseToFullCamelCase(pkg.Name)+".swift"))
	if err != nil {
		return err
	}
	defer f.Close()
	return t.Execute(f, pkg)
}

// swift template
var swiftModelTemplate = `// Code generated by github.com/tinkler/mqttadmin; DO NOT EDIT.
{{range .Structs}}
struct {{.Name}} {
	{{range .Fields}}
	var {{.Name | toCamel}}: {{.Type | toType}};
	{{end}}
	{{range .Methods}}
	func {{.Name | toCamel}}({{range .Args}}{{.Name | toCamel}}: {{.Type | toType}}, {{end}}) -> {{if .Rets}}{{range .Rets}}{{.Type | toType}}, {{end}} {{else}}Void{{end}} {
		
	}
	{{end}}
}
{{end}}
`
